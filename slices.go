package main

import "fmt"

func main() {

	//для вывода слайса на консоль используем fmt. Обычный print будет выводить размер, капасити и адрес в памяти

	//у слайсов не указывается размер. Если указать размер - это будет массив, а не слайс
	var s1 []int //размер будет 0
	fmt.Println("Пустой слайс:", s1) //Пустой слайс: []
	fmt.Println("слайс:", s1, "длина слайса:", len(s1), "капасити:", cap(s1)) //слайс: [] длина слайса: 0 капасити: 0
	s1 = append(s1, 100) //добавили элемент в слайс
	fmt.Println("уже не пустой слайс:", s1) //уже не пустой слайс: [100]
	fmt.Println("слайс:", s1, "длина слайса:", len(s1), "капасити:", cap(s1)) //слайс: [100] длина слайса: 1 капасити: 1

	s1 = append(s1, 102)
	fmt.Println("слайс:", s1, "длина слайса:", len(s1), "капасити:", cap(s1)) //слайс: [100 102] длина слайса: 2 капасити: 2
	s1 = append(s1, 103)
	fmt.Println("слайс:", s1, "длина слайса:", len(s1), "капасити:", cap(s1)) //слайс: [100 102 103] длина слайса: 3 капасити: 4
	s1 = append(s1, 104)
	fmt.Println("слайс:", s1, "длина слайса:", len(s1), "капасити:", cap(s1)) //слайс: [100 102 103 104] длина слайса: 4 капасити: 4
	s1 = append(s1, 123)
	fmt.Println("слайс:", s1, "длина слайса:", len(s1), "капасити:", cap(s1)) //слайс: [100 102 103 104 123] длина слайса: 5 капасити: 8
	//return


	//быстрая инициализация
	sl2 := []int {10, 20, 30}
	fmt.Println("слайс:", sl2, "длина слайса:", len(sl2), "капасити:", cap(sl2)) //слайс: [10 20 30] длина слайса: 3 капасити: 3
	//return


	//добавление слайса в слайс (спред оператор ...)
	//s1 = append(s1, sl2) //так не сработает. Несовместимость типов: ожидается int, а у sl2 тип []int
	s1 = append(s1, sl2...) //получается одномерный слайс, с добавлением элементов из другого слайса
	fmt.Println("слайс:", s1, "длина слайса:", len(s1), "капасити:", cap(s1)) //слайс: [100 102 103 104 123 10 20 30] длина слайса: 8 капасити: 8

	var slm [][]int //слайс слайсов
	slm = append(slm, sl2) //так сработает т.к. slm ожидает тип []int, а у sl2 тип тоже []int
	fmt.Println("слайс:", slm, "длина слайса:", len(slm), "капасити:", cap(slm)) //слайс: [[10 20 30]] длина слайса: 1 капасити: 1
	//return


	//слайс с нужной длиной и капасити
	slice3 := make([]int, 10) //2ой аргумент - длина
	fmt.Println("слайс:", slice3, "длина слайса:", len(slice3), "капасити:", cap(slice3)) //слайс: [0 0 0 0 0 0 0 0 0 0] длина слайса: 10 капасити:

	slice3 = append(slice3, 99999) //добавили новый элемент. Добавление идет в конец т.к. в слайсе уже есть 10 нулей
	fmt.Println("слайс:", slice3, "длина слайса:", len(slice3), "капасити:", cap(slice3)) //слайс: [0 0 0 0 0 0 0 0 0 0 99999] длина слайса: 11 капасити: 20
	//как сделать без нулей:
	slice4 := make([]int, 0, 15) //2ой аргумент - длина (0 - инициализированных нулей не будет). 3ий аргумент - капасити
	fmt.Println("слайс:", slice4, "длина слайса:", len(slice4), "капасити:", cap(slice4)) //слайс: [] длина слайса: 0 капасити: 15
	slice4 = append(slice4, []int{12, 13, 14, 15, 16}...) //добавили элементы другого слайса
	fmt.Println("слайс:", slice4, "длина слайса:", len(slice4), "капасити:", cap(slice4)) //слайс: [12 13 14 15 16] длина слайса: 5 капасити: 15
	//return


	//внутри слайса - ссылка на массив (копируется при присвоении)
	slice5 := slice4
	slice5[2] = 99999999 //значение поменяется у slice5 и у slice4 т.к. они ссылаются на один и тот же массив в памяти
	fmt.Println("slice5:", slice5, "slice4:", slice4)//slice5: [12 13 99999999 15 16] slice4: [12 13 99999999 15 16]
	//нужно быть аккуратным т.к. если у одного из слайсов изменится капасити, то он будет указывать на новый массив в результате чего, оба слайса будут указывать на разные массивы
	//return


	//копирование слайсов
	//неправильно:
	var slice6 []int
	copy(slice6, slice5) //копирование не выполнится т.к. у slice6 капасити и длина 0 и некуда копировать (должны быть такими же, как у копируемого слайса)
	fmt.Println(slice6) //[]

	//правильно:
	slice7 := make([]int, len(slice5), cap(slice5)) //создали слайс с длиной и капасити таким же, как и у slice5. Капасити можно не указывать (будет автоматически равно длине)
	copy(slice7, slice5) //сколько длины и капасити будет у slice7, столько элементов в него и скопируется
	fmt.Println(slice7) //[12 13 99999999 15 16]
	//return


	//часть слайсов
	//[a:b] == [a, b)
	fmt.Println("часть слайса:", slice7[1:3], slice7[:2], slice7[1:]) //часть слайса: [13 99999999] [12 13] [13 99999999 15 16]
	//return


	//создание слайса из массива
	arr := [...]int{5, 6, 7} //массив. ... - сам считает размер
	slice8 := arr[:] //используется ":". slice8 ссылается на массив arr
	fmt.Println("слайс из массива:", slice8) //слайс из массива: [5 6 7]
	//return


}